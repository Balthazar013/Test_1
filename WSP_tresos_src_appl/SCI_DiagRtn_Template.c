
/**
 * \file
 *
 * \brief AUTOSAR Rte
 *
 * This file contains the implementation of the AUTOSAR
 * module Rte.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2013 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

 /*
  * This file contains an Rte component template / example code
  *
  * This file has been automatically generated by
  * EB tresos AutoCore Rte Generator Version 6.1.75
  * on Tue Apr 03 13:39:19 CEST 2018. !!!IGNORE-LINE!!!
  */

 /* \addtogroup Rte Runtime Environment
  * @{ */

#include "Rte_SCI_DiagRtn.h"

/*------------------------[runnable entity skeletons]------------------------*/

#ifdef RTE_PTR2ARRAYTYPE_PASSING
Std_ReturnType SCI_DiagRtn_DiagRtn_DcmDspRoutine_633_Start (P2CONST(Dcm_InStartBufDcmDspRoutine_633_ArrayType, AUTOMATIC, RTE_APPL_CONST) InBuffer, P2VAR(Dcm_OutStartBufDcmDspRoutine_633_ArrayType, AUTOMATIC, RTE_APPL_DATA) OutBuffer, P2VAR(NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
#else
Std_ReturnType SCI_DiagRtn_DiagRtn_DcmDspRoutine_633_Start (P2CONST(uint8, AUTOMATIC, RTE_APPL_CONST) InBuffer, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) OutBuffer, P2VAR(NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
#endif
{
  NvM_SrcPtrType SrcPtr;
  boolean BlockChanged;
  uint8 DataIndex;
  NvM_DstPtrType DstPtr_0;
  NvM_DstPtrType DstPtr;
  NvM_RequestResultType RequestResultPtr;
  uint8 DataIndexPtr;
  GenericByte result;
  GenericByte trigger;
  uint8 Status_0;
  unsigned char Data_2[128];
  uint16 Index_2;
  uint8 Status;
  uint8 Data_1;
  uint16 Index_1;
  NegativeResponseCodeType ErrorCode;
  uint16 DataLength;
  unsigned char Data_0[128];
  uint16 Index_0;
  uint8 Data;
  uint16 Index;
  idt_FodCanState FodCanState;
  P2VAR(MODFreezeState, AUTOMATIC, AUTOMATIC) MODFreezeFlag_0;
  MODFreezeState MODFreezeFlag;
  Std_ReturnType status;

  Rte_IWrite_DiagRtn_DcmDspRoutine_633_Start_PP_MODFreezeFlag_MODFreezeFlag(MODFreezeFlag);

  MODFreezeFlag_0 = Rte_IWriteRef_DiagRtn_DcmDspRoutine_633_Start_PP_MODFreezeFlag_MODFreezeFlag();

  FodCanState = Rte_IRead_DiagRtn_DcmDspRoutine_633_Start_RP_ModSync_State_FodCanState();

  status = Rte_Call_NvmExtServ_NvmExt_DiagRead(Index, &Data);

  status = Rte_Call_NvmExtServ_NvmExt_DiagWrite(Index_0, Data_0, DataLength, &ErrorCode);

  status = Rte_Call_NvmExtServ_NvmExt_Read(Index_1, &Data_1, &Status);

  status = Rte_Call_NvmExtServ_NvmExt_Write(Index_2, Data_2, &Status_0);

  status = Rte_Call_RP_DiagRtn_FodNullVector_Start(trigger, &result);

  status = Rte_Call_PS_NvBlockNeeds_GetDataIndex(&DataIndexPtr);

  status = Rte_Call_PS_NvBlockNeeds_GetErrorStatus(&RequestResultPtr);

  status = Rte_Call_PS_NvBlockNeeds_InvalidateNvBlock();

  status = Rte_Call_PS_NvBlockNeeds_ReadBlock(DstPtr);

  status = Rte_Call_PS_NvBlockNeeds_RestoreBlockDefaults(DstPtr_0);

  status = Rte_Call_PS_NvBlockNeeds_SetDataIndex(DataIndex);

  status = Rte_Call_PS_NvBlockNeeds_SetRamBlockStatus(BlockChanged);

  status = Rte_Call_PS_NvBlockNeeds_WriteBlock(SrcPtr);

  return status;
}

#ifdef RTE_PTR2ARRAYTYPE_PASSING
Std_ReturnType SCI_DiagRtn_DiagRtn_DcmDspRoutine_634_Start (P2CONST(Dcm_InStartBufDcmDspRoutine_634_ArrayType, AUTOMATIC, RTE_APPL_CONST) InBuffer, P2VAR(Dcm_OutStartBufDcmDspRoutine_634_ArrayType, AUTOMATIC, RTE_APPL_DATA) OutBuffer, P2VAR(NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
#else
Std_ReturnType SCI_DiagRtn_DiagRtn_DcmDspRoutine_634_Start (P2CONST(uint8, AUTOMATIC, RTE_APPL_CONST) InBuffer, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) OutBuffer, P2VAR(NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
#endif
{
  uint8 Status_0;
  unsigned char Data_2[128];
  uint16 Index_2;
  uint8 Status;
  uint8 Data_1;
  uint16 Index_1;
  NegativeResponseCodeType ErrorCode;
  uint16 DataLength;
  unsigned char Data_0[128];
  uint16 Index_0;
  uint8 Data;
  uint16 Index;
  Std_ReturnType status;

  status = Rte_Call_NvmExtServ_NvmExt_DiagRead(Index, &Data);

  status = Rte_Call_NvmExtServ_NvmExt_DiagWrite(Index_0, Data_0, DataLength, &ErrorCode);

  status = Rte_Call_NvmExtServ_NvmExt_Read(Index_1, &Data_1, &Status);

  status = Rte_Call_NvmExtServ_NvmExt_Write(Index_2, Data_2, &Status_0);

  return status;
}

/*
  ------------------------[runnable-independent API]-------------------------

  Copy and paste the following API to those runnable entity functions where
  you want to use them.

  ------------------------[port handle API]----------------------------------

  ------------------------[per instance memory API]--------------------------

*/
/** @} doxygen end group definition */
/*==================[end of file]============================================*/

